(* Grammar for the Prose Language - v1.1.0 *)

(* --- Lexical Tokens --- *)
digit = "0"..."9";
letter = "a"..."z" | "A"..."Z";
identifier = (letter | "_") {letter | digit | "_"};

integer_literal = ["-"] digit {digit};
rational_literal = ["-"] digit {digit} "." digit {digit};
string_literal = '"' { (ANY - '"') } '"'; (* Simplified for EBNF *)
boolean_literal = "true" | "false";
literal = integer_literal | rational_literal | string_literal | boolean_literal;

(* --- Types --- *)
primitive_type = "string" | "integer" | "rational" | "boolean" | "void";
struct_type = identifier; (* A user-defined type *)
list_type = "list" "<" (primitive_type | struct_type) ">";
type = primitive_type | struct_type | list_type;

(* --- Expressions (Simplified using operator precedence as comments) --- *)
(* Precedence (low to high): ||, &&, == != > < >= <=, + -, * / % *)

primary_expression = literal | identifier | "(" expression ")";
call_suffix = "(" [expression {"," expression}] ")";
member_access_suffix = "." identifier;
list_access_suffix = "[" expression "]";

postfix_expression = primary_expression {call_suffix | member_access_suffix | list_access_suffix};
(* Note: A full EBNF for precedence climbing is verbose. This is a conceptual representation. *)
expression = postfix_expression {("+"|"-"|"*"|"/"|"%"|"&&"|"||"|"=="|"!="|">"|"<"|">="|"<=") postfix_expression};

(* --- Statements --- *)

statement = (
      declaration_statement
    | assignment_statement
    | struct_definition
    | function_declaration
    | if_statement
    | for_statement
    | while_statement
    | do_while_statement
    | return_statement
    | io_statement
    | expression_statement
);

expression_statement = expression ";";

declaration_statement = "create" type ("variable" | "constant") identifier ["to" expression] ";";
assignment_statement = "set" (identifier | postfix_expression) "to" expression ";";

struct_definition = "create" "type" identifier "(" [type identifier {"," type identifier}] ")" ";";

if_statement = "if" expression "then" {statement}
               {"elif" expression "then" {statement}}
               ["else" {statement}]
               "end";

while_statement = "while" expression "do" {statement} "end";
do_while_statement = "do" {statement} "while" expression "end";
for_statement = "for" identifier "in" expression "do" {statement} "end";

io_statement = (("write" | "writeln") expression | "read" identifier | "readme" identifier expression) ";";

function_declaration = "function" identifier "(" [parameter_list] ")" ["->" type]
                       {statement}
                       "end";

parameter_list = type identifier {"," type identifier};
return_statement = "return" [expression] ";";


(* --- Program Structure --- *)
program_part = function_declaration | struct_definition | statement;
program = {program_part};